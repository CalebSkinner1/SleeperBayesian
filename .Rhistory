source("~/Desktop/Rice/First Year/STAT 525 Bayesian Methods/SleeperBayesian/Modelling.R")
# current year
current_team <- df_2025 %>%
filter(name %in% team) %>%
group_by(name) %>%
mutate(
game_no = row_number()) %>%
ungroup() %>%
full_join(projections, by = join_by("name", "game_no")) %>%
select(date, name, game_no, sleeper_points, sleeper_projection)
current_team
# current year
current_team <- df_2025 %>%
filter(name %in% team) %>%
arrange(date) %>%
group_by(name) %>%
mutate(
game_no = row_number()) %>%
ungroup() %>%
full_join(projections, by = join_by("name", "game_no")) %>%
select(date, name, game_no, sleeper_points, sleeper_projection)
current_team
source("~/Desktop/Rice/First Year/STAT 525 Bayesian Methods/SleeperBayesian/Modelling.R")
singlePlayerMP <- function(n.iter, data, alpha, beta,
theSigma = 1, hSigma = 1,
burnIn = 0) {
## caleb's prop to make function take in less parameters
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points)
gamesPlayed <- length(sleeper_points)
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
#grabs estimate for next game
sleepEst <- data$sleeper_projection[gamesPlayed + 1]
## Initializing Matrices
playerDF <- gamesPlayed - 1
# Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
# postYs <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
# postYs[1, ] <- data
newY <- 1
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- rnorm(1, sleepEst, sqrt(hSigma[j])) # New Est
newY[j] <- rnorm(1, newTheta, sqrt(theSigma[j]))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
multiSamples <- singlePlayerMP(1e+4, data = current_team %>% filter(name == team[1]),
alpha = naiveAlphasBetas$GP[8]/2, beta = naiveAlphasBetas$Betas[8]/2,
burnIn = 5e+4)
# Week Function
week_pred <- function(n.iter, data, week_data, alpha, beta, hSigma = 1, theSigma = 1, burnIn = 0){
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points)
gamesPlayed <- length(sleeper_points)
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
sleepEst <- week_data %>% filter(is.na(sleeper_points)) %>% select(sleeper_projection) %>% pull()
## Initializing Matrices
playerDF <- gamesPlayed - 1
# Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
# postYs <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
# postYs[1, ] <- data
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEst))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map(sleepEst, ~rnorm(1, ., sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, ., sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gamesPlayed+1):(gamesPlayed + length(sleepEst)))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekSamples <- week_pred(1e+4, data = current_team %>% filter(name == team[1]),
week_data = current_team %>% filter(name == team[1]) %>% filter(game_no > 6),
alpha = naiveAlphasBetas$GP[8]/2, beta = naiveAlphasBetas$Betas[8]/2,
burnIn = 5e+4)
source("~/Desktop/Rice/First Year/STAT 525 Bayesian Methods/SleeperBayesian/Modelling.R")
t <- Sys.time()
week_pred(1e+4, data = current_team %>% filter(name == team[6]),
week_data = current_team %>% filter(name == team[6]) %>% filter(game_no > 6),
alpha = naiveAlphasBetas$GP[8]/2, beta = naiveAlphasBetas$Betas[8]/2,
burnIn = 5e+4) %>%
prob_decision(current_team %>% filter(name == team[6]) %>% filter(game_no > 6))
Sys.time() -t
t <- Sys.time()
week_pred(1e+4, data = current_team %>% filter(name == team[7]),
week_data = current_team %>% filter(name == team[7]) %>% filter(game_no > 6),
alpha = naiveAlphasBetas$GP[8]/2, beta = naiveAlphasBetas$Betas[8]/2,
burnIn = 5e+4) %>%
prob_decision(current_team %>% filter(name == team[7]) %>% filter(game_no > 6))
Sys.time() -t
team[7]
