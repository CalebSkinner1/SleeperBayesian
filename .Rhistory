newY[j, ] <- map_dbl(newTheta, ~rnorm(1, ., sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gamesPlayed+1):(gamesPlayed + length(sleepEst)))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(1, "Kyrie Irving", 5, 2)
weekPred(1, "Kyrie Irving", 5, 1)
weekPred(1, "Kyrie Irving", 5, 4)
weekPred <- function(n.iter, playerName, this_week, gp_week,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek)) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
return(c(alpha, beta))
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
sleepEst <- data$sleeper_projection[currentWeek[-1:-gp_week]]
## Initializing Matrices
playerDF <- gamesPlayed - 1
# Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEst))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map(sleepEst, ~rnorm(1, ., sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, ., sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gamesPlayed+1):(gamesPlayed + length(sleepEst)))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(1, "Kyrie Irving", 5, 4)
weekPred(1, "Kyrie Irving", 5, 3)
weekPred(1, "Kyrie Irving", 5, 2)
weekPred <- function(n.iter, playerName, this_week, gp_week,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek)) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
playerDF <- gamesPlayed - 1
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
### Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
sleepEsts <- data$sleeper_projection[currentWeek[-1:-gp_week]]
## Initializing Matrices
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEst))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map_dbl(sleepEsts, ~rnorm(1, .x, sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, .x, sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gamesPlayed+1):(gamesPlayed + length(sleepEst)))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
c(1, 2, 3)[0]
c(1, 2, 3)[NULL]
c(1, 2, 3)[-1:0]
weekPred <- function(n.iter, playerName, this_week, gp_week = 0,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek) | gp_week < 0) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
playerDF <- gamesPlayed - 1
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
### Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
if (gp_week == 0) {
sleepEsts <- data$sleeper_projection[currentWeek]
} else {
sleepEsts <- data$sleeper_projection[currentWeek[-1:-gp_week]]
}
# End if
## Initializing Matrices
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEst))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map_dbl(sleepEsts, ~rnorm(1, .x, sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, .x, sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gamesPlayed+1):(gamesPlayed + length(sleepEst)))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(1, "Kyrie Irving", 5)
weekPred <- function(n.iter, playerName, this_week, gp_week = 0,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek) | gp_week < 0) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
playerDF <- gamesPlayed - 1
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
### Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
if (gp_week == 0) {
sleepEsts <- data$sleeper_projection[currentWeek]
} else {
sleepEsts <- data$sleeper_projection[currentWeek[-1:-gp_week]]
}
# End if
## Initializing Matrices
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEsts))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map_dbl(sleepEsts, ~rnorm(1, .x, sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, .x, sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gamesPlayed+1):(gamesPlayed + length(sleepEsts)))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(1, "Kyrie Irving", 5)
weekPred(2, "Kyrie Irving", 5)
weekPred(2, "Kyrie Irving", 5, 1, burnIn = 1000)
weekPred <- function(n.iter, playerName, this_week, gp_week = 0,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek) | gp_week < 0) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
playerDF <- gamesPlayed - 1
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
### Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
if (gp_week == 0) {
sleepEsts <- data$sleeper_projection[currentWeek]
} else {
sleepEsts <- data$sleeper_projection[currentWeek[-1:-gp_week]]
}
# End if
## Initializing Matrices
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEsts))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map_dbl(sleepEsts, ~rnorm(1, .x, sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, .x, sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gp_week + 1):gp_week)
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(2, "Kyrie Irving", 5, 1, burnIn = 1000)
weekPred <- function(n.iter, playerName, this_week, gp_week = 0,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek) | gp_week < 0) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
playerDF <- gamesPlayed - 1
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
### Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
if (gp_week == 0) {
sleepEsts <- data$sleeper_projection[currentWeek]
} else {
sleepEsts <- data$sleeper_projection[currentWeek[-1:-gp_week]]
}
# End if
## Initializing Matrices
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEsts))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map_dbl(sleepEsts, ~rnorm(1, .x, sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, .x, sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gp_week + 1):length(sleepEsts))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(2, "Kyrie Irving", 5, 1, burnIn = 1000)
weekPred <- function(n.iter, playerName, this_week, gp_week = 0,
consistencyParams = priorPuller(playerName),
hSigma = 1, theSigma = 1, burnIn = 0) {
#####
# Gather Player Data and Prepare It
####
## Find Player Data
data <- full_data %>% filter(name == playerName,
week <= this_week)
## Week Safety Check
currentWeek <- which(data$week == this_week)
if(gp_week >= length(currentWeek) | gp_week < 0) stop("Must have unplayed games remaining in week")
## gp_week acts as an index on currentWeek
## Convert to NA
data$sleeper_points[currentWeek] <- NA
#####
# Prepare for Gibbs
#####
#grabs sleeper points from full data tibble
sleeper_points <- na.omit(data$sleeper_points) # Removes all references to this_week
gamesPlayed <- length(sleeper_points)
playerDF <- gamesPlayed - 1
#grabs projections from data tibble
priorMean <- data$sleeper_projection[1:gamesPlayed]
### Add a stop to make shit clear
if (length(priorMean) != gamesPlayed) stop("Only for multiple priors!\n")
# Set Consistency Priors
alpha <- (consistencyParams[1] - 1)/2
beta <- (consistencyParams[2])/2
#initializes thetaStarts
thetaStarts <- rep(20, gamesPlayed)
# grabs estimates for each game remaining in the week
if (gp_week == 0) {
sleepEsts <- data$sleeper_projection[currentWeek]
} else {
sleepEsts <- data$sleeper_projection[currentWeek[-1:-gp_week]]
}
# End if
## Initializing Matrices
thetaMat <- matrix(1, nrow = n.iter + burnIn + 1, ncol = gamesPlayed)
thetaMat[1, ] <- thetaStarts
newY <- matrix(1, nrow = n.iter + burnIn + 1, ncol = length(sleepEsts))
## Loop
for (j in 2:(n.iter + burnIn + 1)) {
## Hierarchical Variance
hSigma[j] <- 1/rgamma(1, playerDF/2, sum((thetaMat[j - 1, ] - priorMean)^2)/2)
# All deviations should vectorize :)
## Player Consistency
theSigma[j] <- 1/rgamma(1, gamesPlayed/2 + alpha,
sum((sleeper_points - thetaMat[j - 1, ])^2)/2 + beta)
## All Thetas
currentPrecision <- (1/theSigma[j] + 1/hSigma[j])^(-1)
thetaMat[j, ] <- map_dbl(1:gamesPlayed, ~rnorm(1, currentPrecision *
(priorMean[.x]/hSigma[j] + sleeper_points[.x]/theSigma[j]),
sqrt(currentPrecision)))
# Change to index over various prior means
## Posterior Predictive Sampling
newTheta <- map_dbl(sleepEsts, ~rnorm(1, .x, sqrt(hSigma[j]))) # New Estimates
newY[j, ] <- map_dbl(newTheta, ~rnorm(1, .x, sqrt(theSigma[j])))
}
## End for loop
## Prepare Results
resMat <- cbind(thetaMat, theSigma, hSigma, newY)
colnames(resMat)[1:gamesPlayed] <- paste0("theta_", 1:gamesPlayed)
colnames(resMat)[(gamesPlayed + 3):ncol(resMat)] <- paste0("newY_", (gp_week + 1):length(currentWeek))
#colnames(resMat)[(gamesPlayed + 2 + 1):(2 * gamesPlayed + 2)] <- paste0("Game_", 1:gamesPlayed)
return(mcmc(resMat[-1:(-1 * burnIn - 1), ]))
}
weekPred(2, "Kyrie Irving", 5, 1, burnIn = 1000)
weekPred(1e+4, "Kyrie Irving", 5, 1, burnIn = 5000)
weekPred(1e+4, "Kyrie Irving", 5, 1, burnIn = 5000) %>% plot
testPlayer <- weekPred(3.5e+4, "LeBron James", 5,burnIn = 5e+4)
testPlayer <- weekPred(3.5e+4, "LeBron James", this_week = 5, burnIn = 5e+4)
testPlayer <- weekPred(3.5e+4, "LeBron James", 5, 0, burnIn = 5e+4)
testPlayer <- weekPred(1, "LeBron James", 5)
df_2024
full_data
full_data %>% pull(names) %>% tabe
full_data %>% pull(names) %>% table
full_data %>% pull(name) %>% table
testPlayer <- weekPred(3.5e+4, "Shai Gilgeous-Alexander", 5, burnIn = 5e+4)
testPlayer
testPlayer[, 1:14] %>% plot
plot(testPlayer)
plot(testPlayer[, 1])
plot(testPlayer[, 1])
plot(testPlayer[, 2])
plot(testPlayer[, 7])
